## 了解一点数据结构
栈是一个线性结构，特点是只能在某一端添加或删除数据，遵循先进后出/后进先出的原则
队列一个线性结构，特点是在某一端添加数据，在另一端删除数据，遵循先进先出的原则。

## 谈谈二叉树，理解
每个节点都会遍历三次，分别是遍历到自己，遍历左子树和遍历右子树
先序遍历表示先访问根节点，然后访问左节点，最后访问右节点。 (根左右)
中序遍历表示先访问左节点，然后访问根节点，最后访问右节点。（左根右）
后序遍历表示先访问左节点，然后访问右节点，最后访问根节点。（左右根）

## 插入排序和冒泡排序
在平均和最坏情况下的时间复杂度都是 O(n^2)，最好情况下都是 O(n)，空间复杂度是 O(1)

### 插入排序

认为第一个元素是排好序的，从第二个开始遍历。
拿出当前元素的值，从排好序的序列中从后往前找。
如果序列中的元素比当前元素大，就把它后移。直到找到一个小的。
把当前元素放在这个小的后面（后面的比当前大，它已经被后移了）。

最坏和最好时间复杂度
1. 如果序列本来是排好序的，那么会触发最好情况，只需要进行n-1次比较即可，时间复杂度是 O(n)
2. 如果是逆序排列，触发最坏情况，每个元素都要一步步地挪到序列首部，最坏的情况下时间复杂度是 O(n^2)

### 冒泡排序
从第一个元素开始，比较相邻的一对元素。
如果前面的比后面的大，交换它们。
一轮遍历之后最大的元素一定会位于序列结尾。
重复第一步到第三步，每次将剩下的元素中最大的放到剩下元素组成序列的结尾。

任何输入的算法复杂度都是 O(n^2)，空间复杂度是常数 O(1)。但可以记录一个不需要交换的位置，把最好情况的时间复杂度降到 O(n)
维护一个排好序的序列，每次冒泡就会记录最大的那个泡泡的位置作为 end

## 说下快排？时间复杂度多少？基准值怎么选的，为什么？

但数据量一旦超过几万，插入和冒泡的性能会非常差

1. 选取一个 `基准元素` （ 基准元素 ）
2. 比 `基准元素` 小的放到 `基准元素` 左边，比 `基准元素` 大的放到 `基准元素` 右边
3. 对 `基准元素` 左边的序列和右边的序列 分别递归的执行步骤1和步骤2

时间复杂度： 平均情况下是 O(NlogN)，最坏情况是O(n^2)，但通过随机算法(在排序前随机去一个元素和末端元素交换)可以避免最坏情况。

### 空间复杂度呢？

(由于递归调用) 空间复杂度： O(logN)

```js
function quickSort(arr) {
    if(!arr.length) {
        return [];
    } else {
        let [pivot, ...rest] = arr;
        return [
            ...quickSort(rest.filter(e => e <= pivot)),
            pivot,
            ...quickSort(rest.filter(e => e > pivot))
        ]
    }
}
```
