## http 和 https 和 http 2.0

http 是无状态的协议，不会保存状态

HTTPS 还是通过 HTTP 来传输信息，但是信息通过 TLS 协议进行了加密

什么是 TLS 协议
安全传输层协议，用于在两个通信应用程序之间提供保密性和数据完整性。
TLS 协议位于传输层之上，应用层之下，首次进行 TLS 协议传输需要两个 RTT 接下来可以通过Session Resumption 减少到一个 RTT

RTT 是什么？
往返时延
表示从发送端发送数据开始，到发送端收到来自接收端的确认（接收端收到数据之后便立即发送确认），总共经历的时延


TLS 中使用了对称加密和非对称加密
对称加密就是两边拥有相同的密钥，都知道如何加密解密
非对称加密，有公钥和私钥，公钥所有人都知道，可以将数据用公钥加密，将数据解密必须使用私钥解密，私钥只有分发公钥的一方才知道



HTTPS 的实现：服务端向已认证证书颁发机构请求签名，用公钥加密数据发送给客户端，传递对称加密的密码，之后就不再使用非对称加密

HTTP2.0 实现了二进制传输、多路复用、header压缩、服务端推送
**二进制传输**：引入了新的编码机制，所有传输的数据都会被分隔，并采用二进制格式编码
**多路复用**：帧代表着最小的数据单位，每个帧会标识出该帧属于哪个流，多个帧组成流，多路复用就是一个tcp连接中可以存在多条流
发送多个请求，对端可以通过帧中的标识知道属于哪个请求，通过这样的实现，可以避免 HTTP 旧版本中的队头阻塞问题，极大提高传输性能
队头阻塞是指： 一百个请求必须依次逐个发送。第80个请求必须依赖于第79个请求正常返回之后才能发送。这样就平白无故多出了99个网络RTT。PC上的RTT大概是50ms, wifi 为100ms， 3G为200ms，2G为400ms
**header压缩**：HTTP1.1中，使用文本的形式传输 header， header 携带 cookie 的情况下，每次都需要重复传输几百到几千的字节
在 HTTP 2.0 中，使用了 HPACK 压缩格式对传输的 header 进行编码，减少了 header 的大小。并在两端维护了索引表，用于记录出现过的 header ，后面在传输过程中就可以传输已经记录过的 header 的键名，对端收到数据后就可以通过键名找到对应的值。
**服务端 Push**：服务端可以在客户端某个请求后，主动推送其他资源。
某些资源客户端是一定会请求的，这时就可以采取服务端 push 的技术，提前给客户端推送必要的资源，这样就可以相对减少一点延迟时间

**QUIC** 是谷歌基于 udp 实现的同为传输层的协议，http2 底层仍然是 tcp，因为 tcp 的重传机制，只要丢包就要重传，会发生队头阻塞的问题，udp则没有这个问题
支持重传和纠错机制，在只丢失一个包的情况下不需要重传

## GET和POST的区别，状态码

GET和 POST 本质上没有区别，两者都可以在请求链接上或者请求主体上添加参数。
但是在规范场景下，GET 多用于不对服务器上的资源或资源的状态做改变的场景， 例如搜索，获取数据列表

POST 多用于会对服务器上的资源或资源的状态做改变的场景，例如注册，上传文件
在技术上讲。get 请求能被缓存，例如之前我在做开发的时候，ie 就会对get 请求做缓存，所以要给 get 请求加上时间戳，post 不能
Post 相对 GET 安全一点点，因为 get 请求都包含在 url里，能被保存，但是在抓包的情况下两者无差别
post 可以通过请求主体传输更多的数据，get 因为有 url 的长度限制
post 支持更多的编码类型且不对数据类型做限制

状态码： 2xx（成功）， 3xx（重定向）， 4xx（请求无效）， 5xx（服务器错误）
200 请求被正确处理
204 no content 响应报文不含实体的主体部分
206 partial content 进行范围请求

301 moved permanently 永久重定向
302 found 临时重定向
303 see other 表示资源存在着另一个 url
304 资源有本地缓存

400 bad request 请求报文存在语法错误  请求参数中含有 & 或空格，则必须url编码，参数含有中文也需要进行编码
401 unauthorized 表示发送的请求需要有通过 http 认证的认证信息
403 forbidden 表示请求资源的访问被服务器拒绝
404 not found 表示在服务器上没有找到请求的资源

500 internal server error 服务端在执行请求时发生了错误
501 not implemented 不支持当前请求所需要的某个功能
503 service unavailable 服务器超时

协商缓存：If-Modified If-Modified-Since
强缓存： Expires， Cache-Control 来实现

## 输入url到返回，服务端做了什么（dns，三次握手，状态码）

经典面试题
1. DNS 查询，返回访问速度最快的 ip 地址 
2. TCP 三次握手
3. 如果是 https 还有一次交换密钥的过程，开始正式的传输数据
4. 请求在进入服务端之前，可能会经过负责负载均衡的服务器，作用是将请求合理的分发到多台服务器上，假设响应返回了一个 index.html
5. 这时候在客户端会判断状态码是什么，如果是 200 就继续解析，400 500 即报错，300 进行重定向
6. 浏览器开始解析文件，如果经过服务端压缩的话，会先进行解压并通过文件的编码格式解码文件
7. 解码完成后开始正式渲染流程，先根据 HTML 构建 dom 树，有 css 的话构建 cssom 树，如果遇到 script 标签判断是否存在 async 和 defer，前者并行下载并执行，后者先下载等待 html 解析完成后再顺序执行，如果以上都没有，就会阻塞渲染流程直到js执行完毕，遇到文件下载会去下载文件
8. 初始的 html 被完全加载和解析后会触发 DOMcontentLoaded 事件
9. CSSOM 树和 DOM 树构建完成后会开始生成 Render 树，确定元素布局，样式等等
10. 在生成 render 树的过程中，浏览器开始调用 GPU 绘制合成图层，将内容显示在屏幕上

